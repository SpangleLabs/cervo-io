<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Species selector</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.0/jquery.min.js"></script>
    <script src="config.js"></script>
    <link rel="stylesheet" href="style.css" />
    <style>
        /* Always set the map height explicitly to define the size of the div
         * element that contains the map. */
        #map {
            height: 100%;
        }
        /* Optional: Makes the sample page fill the window. */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
    </style>
    <style id="zoo_species_selected"></style>
</head>
<body>
<div style="width: 50%; height: 100%; float: left; position: fixed;">
    <div id="map"></div>
</div>
<div id="selector" style="margin-left: 50%;">
    <a href="index.html">Back to user index</a><br />
    <h1>Just a test species selector</h1>
    Animal list:<ul id='animals' class='odd'></ul>
    <label for="postcode">Your postcode:</label><input id="postcode" type="text" oninput="userUpdatePostcode()"/> <span id="invalid-postcode">Invalid postcode.</span>
    <h2>Zoos with selected species</h2>
    <ul id="selected-zoos"></ul>
</div>
</body>

<script>
    let map;
    let googleMap;
    let animalList;

    /**
     * Wrapper around the google maps Map class, having handy methods
     */
    class Map {

        constructor(googleMap) {
            this.googleMap = googleMap;
            this.cacheZooMarkers = {};
            this.cacheZooInfoWindows = {};
        }

        /**
         * Creates a new google maps marker for a given zoo and saves to cache
         * @param zooData data object of the zoo
         */
        getZooMarker(zooData) {
            const zooId = zooData.zoo_id;
            if (!this.cacheZooMarkers[zooId]) {
                this.cacheZooMarkers[zooId] = new google.maps.Marker({
                    position: {lat: zooData.latitude, lng: zooData.longitude},
                    map: this.googleMap,
                    title: zooData.name
                });
                this.cacheZooMarkers[zooId].addListener("click", function () {
                    const self = this;
                    self.getZooInfoWindow(zooId).open(self.googleMap, self.cacheZooMarkers[zooId]);
                });
            }
            return this.cacheZooMarkers[zooId];
        }

        getZooInfoWindow(zooId) {
            if (!this.cacheZooInfoWindows[zooId]) {
                this.cacheZooInfoWindows[zooId] = new google.maps.InfoWindow({
                    content: ""
                });
                promiseGet(config["api_url"]+"zoos/"+zooId).then(function(zoosData) {
                    const self = this;
                    const zooData = zoosData[0];
                    let infoContent = "<h1>" + zooData.name + "</h1>" +
                        "<a href='" + zooData.link + "'>" + zooData.link + "</a><br />" +
                        "<span style='font-weight: bold'>Postcode:</span> " + zooData.postcode + "<br />" +
                        "<h2>Species:</h2>" +
                        "<ul class='zoo_species'>";
                    $.each(zooData.species, function (idx, zooSpecies) {
                        infoContent += "<li class='zoo_species zoo_species_" + zooSpecies.species_id + "'>" + zooSpecies.common_name + " <span class='latin_name'>" + zooSpecies.latin_name + "</span>";
                    });
                    infoContent += "</ul>";
                    self.cacheZooInfoWindows[zooId].setContent(infoContent);
                });
            }
            return this.cacheZooInfoWindows[zooId];
        }

        userToggleInfoWindow(zooId) {
            $.each(this.cacheZooInfoWindows, function(zooInfoWindowId, infoWindow) {
                if (zooInfoWindowId !== zooId) {
                    infoWindow.close();
                }
            });
            this.getZooInfoWindow(zooId).open(this.googleMap, this.cacheZooMarkers[zooId]);
        }
    }

    class AnimalList {
        constructor() {
            this.cacheCategoryLevel = [];
            this.categories = {};

            const categoryLevelsPromise = promiseGet(config["api_url"]+"category_levels/");
            const firstCategoryPromise = promiseGet(config["api_url"]+"categories/");
            const self = this;
            Promise.all([categoryLevelsPromise, firstCategoryPromise]).then(function(data) {
                self.cacheCategoryLevel = data[0];
                const categoryData = data[1];
                $.each(categoryData, function(index, itemData) {
                    const newCategory = new Category(itemData);
                    self.categories[newCategory.id] = newCategory;

                    userLoadCategory(itemData.category_id);
                });
            });
        }

        getCategoryLevel(id) {
            let result = null;
            $.each(this.cacheCategoryLevel, function(idx, val) {
                if(val.category_level_id === id) {
                    result = val;
                }
            });
            return result;
        }
    }

    class Category {
        constructor(categoryData) {
            this.id = categoryData.category_id;
            this.name = categoryData.name;
            this.levelName = animalList.getCategoryLevel(categoryData.category_level_id).name;
            this.parentCategoryId = categoryData.parent_category_id;
            this.parentCategory = null;
            this.selected = false;
            if(this.parentCategoryId != null) {
                this.parentCategory = animalList.categories[this.parentCategoryId];
                this.selected = this.parentCategory.uiElement.parent().hasClass("selected");
            }
            this.uiElement = this.render();
        }

        render() {
            const categoryLiId = "category-"+this.id;
            const parentUI = this.parentCategory == null ? $("#animals") : this.parentCategory.uiElement;
            parentUI.append(
                `<li class='category closed ${ this.selected ? "selected" : ""}' id='${ categoryLiId }'>
                <span onclick='userLoadCategory(${ this.id })'>
                <span class='category_name'>${ this.name }</span>
                <span class='category_level'>${ this.levelName }</span>
                </span>
                <span class='selector' onclick='userSelectCategory(${ this.id })'></span>
                </li>`);
            return $("#"+categoryLiId);
        }
    }

    /**
     * Adds a new category to the dom
     * @param parentUlElement ul element of the parent category for the category
     * @param categoryData data object for the new category
     */
    function addCategory(parentUlElement, categoryData) {
        const categoryId = categoryData.category_id;
        const name = categoryData.name;
        const categoryLevelId = categoryData.category_level_id;
        const categoryLiId = "category-"+categoryId;
        const categoryLevelName = animalList.getCategoryLevel(categoryLevelId).name;
        parentUlElement.append(
            "<li class='category closed' id='"+categoryLiId+"'>" +
            "<span onclick='userLoadCategory("+categoryId+")'>" +
            "<span class='category_name'>" + name + "</span> " +
            "<span class='category_level'>"+categoryLevelName+"</span>" +
            "</span> " +
            "<span class='selector' onclick='userSelectCategory("+categoryId+")'></span>" +
            "</li>");
        if(parentUlElement.parent().hasClass("selected")) {
            $("#"+categoryLiId).addClass("selected");
        }
    }


    let cacheSpeciesPromises = [];
    let cacheZooDistances = {};
    let currentSelectedSpeciesIds = [];
    let currentSelectedZooIds = [];
    function cacheAddZooDistances(postcode,zooDistanceData) {
        if (!cacheZooDistances[postcode]) {
            cacheZooDistances[postcode] = {};
        }
        $.each(zooDistanceData, function(idx, val) {
            cacheZooDistances[postcode][val.zoo_id] = val.metres;
        });
    }

    /**
     * I pulled this method from somewhere else, tbh
     * @param url
     * @returns {Promise<object>}
     */
    function promiseGet(url) {
        // Return a new promise.
        return new Promise(function (resolve, reject) {
            // Do the usual XHR stuff
            let req = new XMLHttpRequest();
            req.open('GET', url);

            req.onload = function () {
                // This is called even on 404 etc
                // so check the status
                if (req.status === 200) {
                    // Resolve the promise with the response text
                    resolve(JSON.parse(req.responseText));
                } else {
                    // Otherwise reject with the status text
                    // which will hopefully be a meaningful error
                    reject(Error(req.statusText));
                }
            };

            // Handle network errors
            req.onerror = function () {
                reject(Error("Network Error"));
            };

            // Make the request
            req.send();
        });
    }

    /**
     * Retrieves species data from the cache
     * @param id species id to retrieve
     */
    function getSpeciesFromCache(id) {
        if(cacheSpeciesPromises[id]) {
            return cacheSpeciesPromises[id];
        } else {
            const promise = promiseGet(config["api_url"]+"species/"+id).then(function(data) {
                return data[0];
            });
            cacheSpeciesPromises[id] = promise;
            return promise;
        }
    }

    /**
     * Adds a new species to the dom
     * @param parentUlElement ul element of the parent category for the species
     * @param speciesData data object for the new species
     */
    function addSpecies(parentUlElement, speciesData) {
        const speciesId = speciesData.species_id;
        const speciesLiId = "species-"+speciesId;
        const name = speciesData.common_name;
        const latinName = speciesData.latin_name;
        //speciesCache[speciesId] = speciesData;
        parentUlElement.append(
            "<li class='species' id='"+speciesLiId+"'>" +
                "<span class='species_name'>"+name+" </span>" +
                "<span class='latin_name'>"+latinName+"</span>" +
                "<span class='selector' onclick='userSelectSpecies("+speciesId+")'></span>" +
            "</li>");
        if(parentUlElement.parent().hasClass("selected")) {
            $("#"+speciesLiId).addClass("selected");
        }
    }

    function userLoadCategory(id) {
        loadCategory(id, true, false);
    }

    function loadCategory(id, expand, recursive) {
        const categoryLiId = "category-"+id;
        let categoryElem = $("#"+categoryLiId);
        const isOdd = categoryElem.parent("ul").hasClass("odd");
        let populatedCategoriesPromise = Promise.resolve([]);
        if(categoryNotPopulated(categoryElem)) {
            populatedCategoriesPromise = promiseGet(config["api_url"]+"categories/"+id).then(function(/*[CategoryObj]*/categoryObjs) {
                const categoryObj = categoryObjs[0];
                // Add base list element
                categoryElem.append("<ul class='" + (isOdd ? "even" : "odd") + "' style='display: none;'></ul>");
                // Add subcategories
                $.each(categoryObj.sub_categories, function (index, itemData) {
                    addCategory(categoryElem.find("ul"), itemData);
                });
                // Add species in category
                $.each(categoryObj.species, function (index, itemData) {
                    addSpecies(categoryElem.find("ul"), itemData);
                });
                // If category contains only 1 subcategory, open the subcategory. (or if recursive is specified)
                let loadCategoryPromises = [];
                if (categoryElem.children("ul").children("li.category").length === 1 || recursive) {
                    $.each(categoryObj.sub_categories, function (idx, subCategory) {
                        loadCategoryPromises.push(loadCategory(subCategory.category_id, expand, recursive));
                    })
                }
                return Promise.all(loadCategoryPromises);
            });
        } else if (recursive) {
            const subCategoryElems = categoryElem.children("ul").children("li.category");
            let loadCategoryPromises = [];
            subCategoryElems.each(function(idx, elem) {
                loadCategoryPromises.push(loadCategory(elem.id.split("-")[1], expand, recursive));
            });
            populatedCategoriesPromise = Promise.all(loadCategoryPromises);
        }
        return populatedCategoriesPromise.then(function(loadedCategories) {
            if (expand) {
                expandCategory(categoryElem);
            }
        });
    }

    function expandCategory(categoryElem) {
        if(categoryElem.children("ul").is(":visible")) {
            categoryElem.find("ul").first().hide();
            categoryElem.addClass("closed");
            categoryElem.removeClass("open");
        } else {
            categoryElem.find("ul").first().show();
            categoryElem.addClass("open");
            categoryElem.removeClass("closed");
            const childCategoryElems = categoryElem.children("ul").children("li.category");
            if(childCategoryElems.length === 1 && !childCategoryElems.children("ul").is(":visible")) {
                expandCategory(categoryElem.children("ul").children("li.category"));
            }
        }
    }

    /**
     * Checks if a category has been populated with subcategory and species data
     * @param categoryElem category element
     * @returns {boolean}
     */
    function categoryNotPopulated(categoryElem) {
        return !categoryElem.has("ul").length;
    }

    function userSelectCategory(categoryId) {
        let categoryElem = $("li#category-"+categoryId);
        categoryElem.toggleClass("selected");
        categoryElem.find("li").toggleClass("selected");
        loadCategory(categoryId, false, true).then(function(data) {
            updateSelected();
        });
    }

    function userSelectSpecies(speciesId) {
        $("li#species-"+speciesId).toggleClass("selected");
        updateSelected();
    }

    function userUpdatePostcode() {
        let postcode = $("input#postcode").val();
        if (postcode.length >= 2) {
            updateZooDistances();
        }
    }

    function updateZooDistances() {
        //get postcode
        let postcode = $("input#postcode").val();
        // Basic postcode sanity check
        if (postcode.length <= 3) {
            $("#invalid-postcode").show();
            return;
        }
        // check selected zoo list isn't empty
        if (currentSelectedZooIds.length === 0) {
            return;
        }
        //// currentSelectedZooIds;
        promiseGetZooDistances(postcode, currentSelectedZooIds).then(function(zooDistances) {
            $.each(zooDistances, function(idx, val) {
                $("#selected-zoo-"+val.zoo_id+" .distance").text("("+val.metres/1000+"km)");
            });
            domReorderZoos(zooDistances);
        })
    }

    function promiseGetZooDistances(postcode, zooIds) {
        let zoosNeedingDistance = zooIds;
        let foundDistances = [];
        if (cacheZooDistances[postcode]) {
            zoosNeedingDistance = [];
            $.each(zooIds, function(idx, zooId) {
                if (cacheZooDistances[postcode][zooId]) {
                    foundDistances.push({
                        zoo_id: zooId,
                        metres: cacheZooDistances[postcode][zooId]
                    });
                } else {
                    zoosNeedingDistance.push(zooId);
                }
            });
        }
        if (zoosNeedingDistance.length === 0) {
            $("#invalid-postcode").hide();
            return new Promise(function(resolve, reject) {
                resolve(foundDistances);
            })
        }
        //create url to request
        let url = config["api_url"]+"zoo_distances/"+postcode+"/"+zoosNeedingDistance.join(",");
        //get response
        return promiseGet(url).then(function(newDistances) {
            $("#invalid-postcode").hide();
            cacheAddZooDistances(postcode, newDistances);
            return foundDistances.concat(newDistances);
        }).catch(function(err) {
            //if response is 500, "invalid postcode"
            $("#invalid-postcode").show();
        });
    }

    function domReorderZoos(distances) {
        const distancesSorted = distances.sort(function(a, b) { return b.metres - a.metres});
        $.each(distancesSorted, function(idx, distance) {
            const zooLi = $("li#selected-zoo-"+distance.zoo_id);
            zooLi.parent().prepend(zooLi);
        });
    }

    function hideAllMarkers() {
        $.each(cacheZooInfoWindows, function(zooId, infoWindow) {
            if (!currentSelectedZooIds.includes(zooId)) {
                infoWindow.close();
            }
        });
        $.each(cacheZooMarkers, function(zooId, marker) {
            marker.setVisible(false);
        });
        $("li.zoo_species").removeClass("selected_species");
    }

    function updateSelected() {
        currentSelectedSpeciesIds = [];
        currentSelectedZooIds = [];
        let zooSpeciesSelected = $("#zoo_species_selected");
        zooSpeciesSelected.empty();
        let speciesDataPromises = [];
        $("li.species.selected").each(function(idx, elem) {
            const speciesId = elem.id.split("-")[1];
            zooSpeciesSelected.append("li.zoo_species_"+speciesId+" { font-weight:bold; }");
            currentSelectedSpeciesIds.push(speciesId);

            speciesDataPromises.push(getSpeciesFromCache(speciesId).then(function(/*SpeciesObj*/speciesData) {
                let selectedZoos = {};
                $.each(speciesData.zoos, function (zooIdx, zooData) {
                    selectedZoos[zooData.zoo_id] = zooData;
                });
                return selectedZoos;
            }));
        });
        Promise.all(speciesDataPromises).then(function(selectedZooList) {
            const selectedZoos = Object.assign({}, ...selectedZooList);
            // Update zoos selected
            let selectedZoosElem = $("#selected-zoos");
            selectedZoosElem.empty();
            currentSelectedZooIds = Object.keys(selectedZoos);
            hideAllMarkers();
            $.each(selectedZoos, function(zooKey, zooData) {
                selectedZoosElem.append("<li id='selected-zoo-"+zooData.zoo_id+"' onclick='map.userToggleInfoWindow("+zooData.zoo_id+")'>"+zooData.name+" <span class='distance'></span></li>");
                const marker = map.getZooMarker(zooData);
                marker.setVisible(true);
            });
            updateZooDistances();
        });
    }

    $(document).ready(function() {
        animalList = new AnimalList();
    });

    function initMap() {
        googleMap = new google.maps.Map(document.getElementById('map'), {
            zoom: 6,
            center: {lat: 55, lng: -3}
        });
        map = new Map(googleMap);
    }
</script>
<script async defer
        src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDDRJjxehwEZJq1f9XLJL_96tvPvvjzIvk&callback=initMap">
</script>
</html>